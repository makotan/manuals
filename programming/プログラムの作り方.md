# 最初に見るポイント
- 扱うデータ構造(入力と出力)
- 外部I/O
- 既に存在するDBの構造
- 要求されている機能

# やること

## 共通でやることを確認する
- 外部への通知
- ログの出力
- その他プロジェクト毎に決められてる事を事前に確認する

事前にドキュメント化してない場合、手元でドキュメントを作って公開しましょう

## 入力と出力のデータ構造をしっかり定義する
仕様にある場合はそれに従う  
無い場合は案を作って確認するか、事前に用意して貰う  
いずれにしろ重要なのでドキュメントが必要になる  
このときに処理がエラーになったの時のデータ構造も定義する(共通としてあればそれを利用する)  

## 外部IOで扱うデータ構造をしっかり認識する
外部IOへのアクセス方法と必要なライブラリなどの存在を確認する  
テスト等で高頻度でアクセスして良いのか、それとも高頻度でのアクセスは好ましくないのかを確認する  
高頻度でのアクセスが好ましくない場合  
- 代わりのサービスを使ってモック化を検討する
- 内部的に切り替え可能にしてテストの時などは切替可能な設計にしておく

前にやってる人を探して、居ればその人に相談する。自信が無ければ他の人にサポートを依頼する

## 既に存在するDB構造を理解する
- キーとなる項目はどれか
- フラグ的に扱っている項目はどれか
- システム的に付与している項目はどれか
- それぞれの項目に対して元の入力と出力の関係を確認する

DB構造に不足がある場合、設計して確認するか設計して貰う  
ドキュメントへの反映手順とかに制約があることもあるので事前に確認しておく

## 機能(とデータの状態)_を洗い出す
- 要求されている機能は？
- 要求はされていないけど、必要な機能は？
- データ構造には状態(フラグ)がある？
- 状態のパターンは？
- 状態遷移の制約は？
- 導出データの為の物データは足りてる？

これらをふまえて必要な機能が存在しているかを確認する  
特にデータの状態(入出力も含む)がしっかり定義されてないと後からバグが発生しやすくなるので注意

## プログラムを設計する
機能単位で設計する
- 入力と出力(エラー時含む)を確定する
- 必要なDBのテーブルを確定する
- 外部IOを確定する
- 入力のバリデーション(エラーチェック)の仕様を決める
- 入力＋DBを元にしたバリデーションの仕様を決める
- メインの処理の挙動を決める
- メインの処理を考えるときには常にデータの状態に気を配る
- 必要に応じて外部IOを実施する
- ここまでの情報を元に出力を作って返す

共通でやることが入ってるかを確認する  
リアルタイム処理で負荷のかかりそうな処理があれば非同期化も検討する  
非同期化の方法はアーキテクチャに強く依存するし経験が必要なので事前に確認しておく

設計の結果、追加で必要な機能が出てくることもある  
（機能を忘れてた！って時はたいていの場合、状態の配慮不足）

## 実装する
設計した内容をさらに細かく分割していく  
分割の結果、自分が迷わずに書けるサイズにする事  
そうすることで自然とユニットテストしやすい単位になるはず  
実装とユニットテストを高頻度で繰り返す(TDDで実装するのも有り)  
ユニットテストでカバー出来る範囲はなるべく細かくカバーする  
ただし、外部サービスへの依存があったりで仕方ないときは別途モックなどを用意する  
ここのユニットテストはあくまで実装が思い通りかどうかの確認をする事

## テストする
入力のパターンとDBのデータのパターンと出力のパターンに着目してテストを実施する  
特に機能とデータのパターンのカバー範囲を広げることに注力する  
複数の機能をまとめてテストした方がやりやすいならそれも可  
この場合のテストは出来る限り再実行可能な形態のテストにする  
外部IOを実際にテストするかどうかは外部IOのキャパシティ次第  
この段階でエラー時の挙動もテストは完了させる(実装のテストと組み合わせて完了すれば良い)

## 最終テストする
要望通りに動くのかどうか、単独ではなく全体として確認するためのテストをする  
大事なポイントは
- 当初の要望を満たしていること
- エラー時の挙動(リカバリ)も含めて問題ないこと
